package x86

import (
	"github.com/tsavola/wag/internal/gen"
	"github.com/tsavola/wag/internal/links"
	"github.com/tsavola/wag/internal/regs"
	"github.com/tsavola/wag/internal/types"
	"github.com/tsavola/wag/internal/values"
)

func (mach X86) ConversionOp(code gen.RegCoder, name string, resultType, sourceType types.T, x values.Operand) values.Operand {
	switch name {
	case "i32.wrap/i64":
		if reg, zeroExt, ok := x.CheckTempReg(); ok && zeroExt {
			return values.TempRegOperand(reg, false)
		} else {
			return x
		}
	}

	sourceReg, sourceZeroExt, own := mach.opBorrowMaybeScratchReg(code, sourceType, x, false)
	if own {
		defer code.FreeReg(sourceType, sourceReg)
	}

	resultZeroExt := false

	switch name {
	case "f32.convert_s/i32", "f32.convert_s/i64", "f64.convert_s/i32", "f64.convert_s/i64":
		Cvtsi2sSSE.opReg(code, resultType, sourceType, regResult, sourceReg)

	case "f32.convert_u/i32", "f64.convert_u/i32":
		if !sourceZeroExt {
			Mov.opFromReg(code, types.I32, sourceReg, sourceReg)
		}
		Cvtsi2sSSE.opReg(code, resultType, types.I64, regResult, sourceReg)

	case "f32.convert_u/i64", "f64.convert_u/i64":
		mach.opConvertUnsignedI64ToFloat(code, resultType, sourceReg)

	case "i64.extend_s/i32":
		Movsxd.opFromReg(code, 0, regResult, sourceReg)

	case "i64.extend_u/i32":
		Mov.opFromReg(code, sourceType, regResult, sourceReg)

	case "f32.demote/f64", "f64.promote/f32":
		Cvts2sSSE.opFromReg(code, sourceType, regResult, sourceReg)

	case "f32.reinterpret/i32", "f64.reinterpret/i64":
		MovSSE.opFromReg(code, sourceType, regResult, sourceReg)

	case "i32.reinterpret/f32", "i64.reinterpret/f64":
		MovSSE.opToReg(code, sourceType, regResult, sourceReg)
		resultZeroExt = true

	case "i32.trunc_s/f32", "i32.trunc_s/f64", "i64.trunc_s/f32", "i64.trunc_s/f64":
		CvttsSSE2si.opReg(code, sourceType, resultType, regResult, sourceReg)

	case "i32.trunc_u/f32", "i32.trunc_u/f64":
		CvttsSSE2si.opReg(code, sourceType, types.I64, regResult, sourceReg) // larger target size

	default:
		panic(name)
	}

	return values.TempRegOperand(regResult, resultZeroExt)
}

func (mach X86) opConvertUnsignedI64ToFloat(code gen.Coder, floatType types.T, intReg regs.R) {
	var intReg2 regs.R

	if intReg == regScratch {
		intReg2 = regResult
	} else {
		intReg2 = regScratch
	}

	// this algorithm is copied from code generated by gcc and clang:

	var done links.L
	var huge links.L

	Test.opFromReg(code, types.I64, intReg, intReg)
	Js.rel8.opStub(code)
	huge.AddSite(code.Len())

	// max. 63-bit value
	Cvtsi2sSSE.opReg(code, floatType, types.I64, regResult, intReg)

	JmpRel.rel8.opStub(code)
	done.AddSite(code.Len())

	huge.Address = code.Len()
	mach.updateSites8(code, &huge)

	// 64-bit value
	Mov.opFromReg(code, types.I64, intReg2, intReg)
	And.opImm(code, types.I64, intReg2, 1)
	ShrImm.op(code, types.I64, intReg, 1)
	Or.opFromReg(code, types.I64, intReg, intReg2)
	Cvtsi2sSSE.opReg(code, floatType, types.I64, regResult, intReg)
	AddsSSE.opFromReg(code, floatType, regResult, regResult)

	done.Address = code.Len()
	mach.updateSites8(code, &done)
}
